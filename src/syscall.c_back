

#include "syscall.h"
#include "util.h"
#include "asm_tools.h"
#include <stdint.h>
#include "hw.h"
#include "sched.h"

#define WORD_SIZE 4

#define REBOOT_INT 1
#define NOP_INT 2
#define SYS_TIME 3
#define SYS_TIME_GT 4
#define YIELDTO 5

int stack_pointer;

void sys_reboot()
{
	__asm("mov r0, %0" : :"r"(REBOOT_INT) : "r0");    // ecriture registre
	__asm("SWI #0");
	//__asm("bl swi_handler");


}


void __attribute__((naked)) swi_handler(void)
{
	//sauvegarde du context
	__asm("stmfd sp!, {r0-r12,lr}");
	__asm("mov %0, sp" : "=r"(stack_pointer) );  // lecture registre

	int num_intp;
	__asm("mov %0, r0" : "=r"(num_intp ) : : "r0");  // lecture registre


	switch(num_intp)
	{
		case REBOOT_INT :
			do_sys_reboot();			
			break;

		case NOP_INT :
			do_sys_nop();
			break;

		case SYS_TIME :
			
			do_sys_settime();
			break;
		
		case SYS_TIME_GT :
			do_sys_gettime();
			break;

		case YIELDTO :
			do_sys_yieldto();
			break;

		default :
			PANIC();
		break;
	}

	//restaurer context
	__asm("ldmfd sp!, {r0-r12,pc}^");

}


void do_sys_reboot()
{
	__asm("mov pc, %0" : :"r"(0) ); 

	/*const int PM_RSTC = 0x2010001c;
	const int PM_WDOG = 0x20100024;
	const int PM_PASSWORD = 0x5a000000;
	const int PM_RSTC_WRCFG_FULL_RESET = 0x00000020;

	Set32(PM_WDOG, PM_PASSWORD | 1);
	Set32(PM_RSTC, PM_PASSWORD | PM_RSTC_WRCFG_FULL_RESET);
	while(1);*/

	
}


void sys_nop()
{

	__asm("mov r0, %0" : :"r"(NOP_INT) : "r0");    // ecriture registre
	__asm("SWI #0");

	

}
void do_sys_nop()
{

	//__asm("msr SPSR_svc CPSR");	
	//__asm("b LR_svc");
	
}


void sys_settime(uint64_t date_ms)
{
	
	__asm("mov r0, %0" : :"r"(SYS_TIME) : "r0");    // ecriture registre
	__asm("mov r1, %0" : :"r"(date_ms) : "r1");    // ecriture registre
	__asm("mov r2, %0" : :"r"(date_ms >> 32) : "r2");    // ecriture registre
	__asm("SWI #0");

}


void do_sys_settime()
{
	uint64_t date_ms;
	uint64_t a;
	uint64_t b;

	a = *(int *)(stack_pointer+sizeof(int));
	b = *(int *)(stack_pointer+2*sizeof(int));
	date_ms = (a & 0x00000000ffffffff) | (b << 32) ;
	//date_ms = date_ms+1;

	set_date_ms(date_ms);

}


uint64_t sys_gettime()
{
	
	__asm("mov r0, %0" : :"r"(SYS_TIME_GT) : "r0");    // ecriture registre
	__asm("SWI #0");

	uint64_t date_ms;
	uint64_t fort;
	uint64_t faible; 

	__asm("mov %0, r0" : "=r"(faible) );  // lecture registre
	__asm("mov %0, r1" : "=r"(fort) );  // lecture registre


	date_ms = (faible & 0x00000000ffffffff) | (fort << 32) ;

	return date_ms;

}


void do_sys_gettime()
{
	uint64_t date_ms;

	date_ms = get_date_ms();

	*(int *)stack_pointer = (int)(date_ms & 0x00000000ffffffff) ; // faible
	*(int *)(stack_pointer+sizeof(int)) = (int)((date_ms & 0xffffffff00000000) >> 32 ) ; // fort

}



void sys_yieldto(pcb_s* dest)
{

	//int tmp;

	__asm("mov r0, %0" : :"r"(YIELDTO) : "r0");    // ecriture registre
	__asm("mov r1, %0" : :"r"(dest) : "r1");    // ecriture registre
	//__asm("mov %0, lr" : "=r"(tmp) );           // lecture registre
	//__asm("mov r2, %0" : :"r"(tmp) : "r2");    // ecriture registre
	__asm("SWI #0");

}



void do_sys_yieldto_x()
{
	int * p_stack_pointer = (int*)(stack_pointer);

	pcb_s* dest = (pcb_s *)(*(p_stack_pointer +1));
	//dest = dest;	

	//pile svc  -> global current process
	current_process->r0 = *(p_stack_pointer); 
	current_process->r1 = *(int*)(stack_pointer+WORD_SIZE); 
	current_process->r2 = *(int*)(stack_pointer+WORD_SIZE*2); 
	current_process->r3 = *(int*)(stack_pointer+WORD_SIZE*3); 
	current_process->r4 = *(int*)(stack_pointer+WORD_SIZE*4); 
	current_process->r5 = *(int*)(stack_pointer+WORD_SIZE*5); 
	current_process->r6 = *(int*)(stack_pointer+WORD_SIZE*6); 
	current_process->r7 = *(int*)(stack_pointer+WORD_SIZE*7); 
	current_process->r8 = *(int*)(stack_pointer+WORD_SIZE*8); 
	current_process->r9 = *(int*)(stack_pointer+WORD_SIZE*9); 
	current_process->r10 = *(int*)(stack_pointer+WORD_SIZE*10); 
	current_process->r11 = *(int*)(stack_pointer+WORD_SIZE*11); 
	current_process->r12 = *(int*)(stack_pointer+WORD_SIZE*12);
	current_process->lr_svc = *(int*)(stack_pointer+WORD_SIZE*13); 

	//current_process-> lr_usr = (*(p_stack_pointer +2));

	//current_process = dest;

	__asm("cps 0b11111");				// passage au mode systeme
	__asm("mov %0, lr" : "=r"(current_process->lr_usr) );   // lecture registre
	__asm("cps 0b10011"); 				// passage au mode svc

	// dest -> pile svc 
	*(p_stack_pointer)= dest->r0; 
	*(int*)(stack_pointer+WORD_SIZE) = dest->r1; 
	*(int*)(stack_pointer+WORD_SIZE*2) = dest->r2 ; 
	*(int*)(stack_pointer+WORD_SIZE*3) = dest->r3 ; 
	*(int*)(stack_pointer+WORD_SIZE*4) = dest->r4 ; 
	*(int*)(stack_pointer+WORD_SIZE*5) = dest->r5 ; 
	*(int*)(stack_pointer+WORD_SIZE*6) = dest->r6  ; 
	*(int*)(stack_pointer+WORD_SIZE*7) = dest->r7 ; 
	*(int*)(stack_pointer+WORD_SIZE*8) = dest->r8 ; 
	*(int*)(stack_pointer+WORD_SIZE*9) = dest->r9 ; 
	*(int*)(stack_pointer+WORD_SIZE*10) = dest->r10 ; 
	*(int*)(stack_pointer+WORD_SIZE*11) = dest->r11 ; 
	*(p_stack_pointer+12) = dest->r12 ;
	*(p_stack_pointer+13) = dest->lr_svc;
	//*(int*)(stack_pointer+WORD_SIZE*13) = dest->lr ; 

	//
	

}


void do_sys_yieldto_xx()
{
	int lr;
	int * p_stack_pointer = (int*)(stack_pointer);
	pcb_s* dest = (pcb_s *)(*(p_stack_pointer +1));

	__asm("mov %0, lr" : "=r"(lr) );  // lecture registre


	//pile svc  -> global current process
	current_process->r0 = *(p_stack_pointer); 
	current_process->r1 = *(int*)(stack_pointer+WORD_SIZE); 
	current_process->r2 = *(int*)(stack_pointer+WORD_SIZE*2); 
	current_process->r3 = *(int*)(stack_pointer+WORD_SIZE*3); 
	current_process->r4 = *(int*)(stack_pointer+WORD_SIZE*4); 
	current_process->r5 = *(int*)(stack_pointer+WORD_SIZE*5); 
	current_process->r6 = *(int*)(stack_pointer+WORD_SIZE*6); 
	current_process->r7 = *(int*)(stack_pointer+WORD_SIZE*7); 
	current_process->r8 = *(int*)(stack_pointer+WORD_SIZE*8); 
	current_process->r9 = *(int*)(stack_pointer+WORD_SIZE*9); 
	current_process->r10 = *(int*)(stack_pointer+WORD_SIZE*10); 
	current_process->r11 = *(int*)(stack_pointer+WORD_SIZE*11); 
	current_process->r12 = *(int*)(stack_pointer+WORD_SIZE*12);
	current_process->lr_svc = lr;//*(int*)(stack_pointer+WORD_SIZE*13); 

	__asm("cps 0b11111");				// passage au mode systeme
	__asm("mov %0, lr" : "=r"(current_process->lr_usr) );   // lecture registre
	__asm("mov %0, sp" : "=r"(current_process->sp) );   // lecture registre
	__asm("cps 0b10011"); 				// passage au mode svc


	//current_process-> lr_usr = (*(p_stack_pointer +2));

	current_process = dest;


	// dest -> pile svc 
	*(p_stack_pointer)= current_process ->r0; 
	*(int*)(stack_pointer+WORD_SIZE) = current_process ->r1; 
	*(int*)(stack_pointer+WORD_SIZE*2) = current_process ->r2 ; 
	*(int*)(stack_pointer+WORD_SIZE*3) = current_process ->r3 ; 
	*(int*)(stack_pointer+WORD_SIZE*4) = current_process ->r4 ; 
	*(int*)(stack_pointer+WORD_SIZE*5) = current_process ->r5 ; 
	*(int*)(stack_pointer+WORD_SIZE*6) = current_process ->r6 ; 
	*(int*)(stack_pointer+WORD_SIZE*7) = current_process ->r7 ; 
	*(int*)(stack_pointer+WORD_SIZE*8) = current_process ->r8 ; 
	*(int*)(stack_pointer+WORD_SIZE*9) = current_process ->r9 ; 
	*(int*)(stack_pointer+WORD_SIZE*10) = current_process ->r10 ; 
	*(int*)(stack_pointer+WORD_SIZE*11) = current_process ->r11 ; 
	*(p_stack_pointer+12) = current_process ->r12 ;
	*(p_stack_pointer+13) = current_process ->lr_usr;

	__asm("cps 0b11111");				// passage au mode systeme
	__asm("mov lr, %0" : :"r"(current_process->lr_usr));    // ecriture registre
	__asm("mov sp, %0" : :"r"(current_process->sp));    // ecriture registre
	__asm("cps 0b10011"); 				// passage au mode svc
	


	

}


void do_sys_yieldto()
{
	int lr,i;
	int * p_stack_pointer = (int*)(stack_pointer);
	pcb_s* dest = (pcb_s *)(*(p_stack_pointer +1));

	__asm("mov %0, lr" : "=r"(lr) );  // lecture registre


	// Sauvegarde process current
	//current_process->r0 = *(p_stack_pointer); 
	int * p_curr_procss = (int*)current_process;
	for(i=0;i<14;i++)
	{
		*(p_curr_procss+i) = *(p_stack_pointer+i);
	}

	__asm("cps 0b11111");					// passage au mode systeme
	__asm("mov %0, lr" : "=r"(current_process->lr_usr) );   // lecture registre
	__asm("mov %0, sp" : "=r"(current_process->sp) );   	// lecture registre
	__asm("cps 0b10011"); 					// passage au mode svc

	// echange de context
	current_process = dest;

	for(i=0;i<14;i++)
	{
		*(p_stack_pointer+i) = *(p_curr_procss+i);
	}

	__asm("cps 0b11111");					// passage au mode systeme
	__asm("mov lr, %0" : :"r"(current_process->lr_usr));    // ecriture registre
	__asm("mov sp, %0" : :"r"(current_process->sp));    	// ecriture registre
	__asm("cps 0b10011"); 					// passage au mode svc
	
}







